# Выбор датасета
Был использован датасет Успеваемость студентов на экзаменах. Данный датасет был создан для анализа влияния образования родителей, подготовки к тестам и т.д. на успеваемость учащихся. В датасете 8 столбцов: пол, национальность (в не уточняющихся группах), образование родителей, обед, подготовка к курсу, балл по математике, балл за чтение, балл за письмо.

## Столбчатая диаграмма
Построение столбчатой диаграммы (.bar) с использованием модуля graph_objs из библиотеки Plotly.
![image](https://github.com/antaress-s/BigData/assets/77542922/e11a6c8d-69b8-415a-aa29-0bf4d7d9a833)

## Круговая диаграмма
Построение круговой диаграммы (go.Pie).
![image](https://github.com/antaress-s/BigData/assets/77542922/772f1927-e81a-4a01-a301-57a2cdf6e37a)

## Линейные графики
Построение линейных графиков
Оценки по разным направлениям имеют прямую пропорциональную зависимость.
![image](https://github.com/antaress-s/BigData/assets/77542922/c8d9001a-b4ae-4351-93cf-6566a4adfd25)

## Визуализация многомерных данных
В данном примере мы загружаем набор данных Iris и разделяем его на матрицу признаков `X` и вектор меток классов `y`. Затем мы применяем t-SNE к данным с помощью `TSNE` из библиотеки `scikit-learn` и устанавливаем значение perplexity равным 30. После этого мы визуализируем результаты с помощью `scatterplot` из библиотеки `seaborn` и устанавливаем цвета точек в соответствии с метками классов. Значение perplexity влияет на результаты визуализации. Оно определяет, насколько близко объект обрабатывает другие объекты во время построения вложения. Более высокое значение perplexity может привести к усреднению кластеров, в то время как более низкое значение может привести к группировке точек вокруг отдельных объектов или малых кластеров.
![image](https://github.com/antaress-s/BigData/assets/77542922/179c06e1-8aef-4a08-a3de-9d09798ea6f0)
![image](https://github.com/antaress-s/BigData/assets/77542922/4fc82f6b-c575-4bfb-842f-16c22f8273cb)
![image](https://github.com/antaress-s/BigData/assets/77542922/0e946aa3-64c2-49d7-b3cd-316a40946075)

С помощью UMAP получили результат, очень похожий на то, что дает t-SNE. 
n_neighbors=5, min_dist=0.1, time=1.9389050006866455
n_neighbors=5, min_dist=0.6, time=1.6654314994812012
n_neighbors=25, min_dist=0.1, time=1.8912675380706787
n_neighbors=25, min_dist=0.6, time=1.8650519847869873
n_neighbors=50, min_dist=0.1, time=2.0653607845306396
n_neighbors=50, min_dist=0.6, time=1.7542290687561035
t-SNE time=0.5671863555908203
![image](https://github.com/antaress-s/BigData/assets/77542922/edf241c4-8a68-4665-bda6-0cbebfe4ec4d)

t-SNE и UMAP работают похожим образом - они стремятся сохранить относительные расстояния между точками данных, но при этом учитывают их вероятности или плотность. Это позволило сгруппировать похожие данные ближе друг к другу, а различные данные - дальше друг от друга.
